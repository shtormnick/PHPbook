# Обработка ошибок и исключений

Обработка ошибок - это процесс обнаружения ошибок, вызванных вашей программой, а затем принятия соответствующих мер. 
Если вы будете правильно обрабатывать ошибки, это может привести ко многим непредвиденным последствиям.


## Использование функции die ()
При написании вашей программы PHP вы должны проверить все возможные условия ошибки перед тем, как идти вперед, и при необходимости предпринять соответствующие действия.

Попробуйте привести пример без файла /tmp/test.xt и с этим файлом.

```
<?php
   if(!file_exists("/tmp/test.txt")) {
      die("File not found");
   }else {
      $file = fopen("/tmp/test.txt","r");
      print "Opend file sucessfully";
   }
   // Test of the code here.
?>
```

Таким образом, вы можете написать эффективный код. Используя вышеприведенную технику, 
вы можете остановить свою программу всякий раз, когда она выдает ошибки и отображает более содержательные и удобные для пользователя сообщения.

## Определение пользовательской функции обработки ошибок

Вы можете написать свою собственную функцию для обработки любой ошибки. 
PHP предоставляет вам структуру для определения функции обработки ошибок.

Эта функция должна иметь возможность обрабатывать минимум два параметра (уровень ошибки и сообщение об ошибке), но может принимать до пяти параметров (опционально: файл, номер строки и контекст ошибки) -

### Синтаксис

```error_function(error_level,error_message, error_file,error_line,error_context);```

* **error_level**
  
  Обязательный параметр - задает уровень отчета об ошибке для пользовательской ошибки. Значение должно быть числом.
  
* **error_message**
  
  Обязательный параметр - указывает сообщение об ошибке для пользовательской ошибки
  
* **error_file**
    
    Необязательно. Указывает имя файла, в котором произошла ошибка.
    
* **error_line**
    
    Необязательно. Указывает номер строки, в которой произошла ошибка.
    
* **error_context**
    
    Необязательно. Указывает массив, содержащий каждую переменную, и их значения, используемые при возникновении ошибки.
    
### Возможные уровни ошибок

Эти уровни отчетов об ошибках представляют собой различные типы ошибок, к которым может использоваться пользовательский обработчик ошибок. 
Эти значения используются в комбинации с использованием | оператор

* **.E_ERROR**
    
    Неустранимая ошибки во время выполнения. Выполнение сценария останавливается

* **E_WARNING**
    
    Нефатальные ошибки во время выполнения. Выполнение скрипта не останавливается

* **E_PARSE**
    
    Ошибки анализа времени компиляции. Ошибки анализа должны генерироваться только парсером.

* **E_NOTICE**
    
    Уведомления о времени выполнения. Скрипт нашел что-то, что может быть ошибкой, но может также произойти при обычном сценарии
    
* **E_CORE_ERROR**
    
    Неустранимая ошибки, возникающие во время первоначального запуска PHP.

* **E_CORE_WARNING**
    
    Нефатальные ошибки во время выполнения. Это происходит во время первоначального запуска PHP.
    
* **E_USER_ERROR**
    
    Неустранимая пользовательская ошибка. Это похоже на набор E_ERROR программиста, использующий функцию PHP trigger_error ()
    
* **E_USER_WARNING**
    
    Нефатальное пользовательское предупреждение. Это похоже на E_WARNING, установленный программистом с использованием функции PHP trigger_error ()
    
* **E_USER_NOTICE**
    
    Пользовательское уведомление. Это похоже на набор E_NOTICE, заданный программистом с использованием функции PHP trigger_error ()
   
* **E_STRICT**
    
    Уведомления о времени выполнения. Включите, чтобы PHP предлагал изменения в вашем коде, что обеспечит лучшую совместимость и передовую совместимость вашего кода.

* **E_RECOVERABLE_ERROR**
    
    Ловкая ошибка. Это похоже на E_ERROR, но может быть захвачен определяемым пользователем дескриптором (см. Также set_error_handler ())

* **E_ALL**
    
    Все ошибки и предупреждения, кроме уровня E_STRICT (E_STRICT будет частью E_ALL с PHP 6.0)

Все указанные выше уровни ошибок можно задать, используя встроенную библиотечную функцию PHP, где уровень кабина будет любым значением, определенным в таблице выше.

```int error_reporting ( [int $level] )```

Ниже приведен способ создания одной функции обработки ошибок -

```
<?php
   function handleError($errno, $errstr,$error_file,$error_line) {
      echo "<b>Error:</b> [$errno] $errstr - $error_file:$error_line";
      echo "<br />";
      echo "Terminating PHP Script";
      
      die();
   }
?>
```

После того, как вы определили свой собственный обработчик ошибок, вам нужно установить его с помощью встроенной библиотеки set_error_handler. 
Теперь рассмотрим наш пример, вызывая функцию, которая не существует.
```
<?php
   error_reporting( E_ERROR );
   
   function handleError($errno, $errstr,$error_file,$error_line) {
      echo "<b>Error:</b> [$errno] $errstr - $error_file:$error_line";
      echo "<br />";
      echo "Terminating PHP Script";
      
      die();
   }
   
   //set error handler
   set_error_handler("handleError");
   
   //trigger error
   myFunction();
?>
```

## Обработка исключений

PHP 5 имеет модель исключения, аналогичную модели других языков программирования. Исключения важны и обеспечивают лучший контроль над обработкой ошибок.

Давайте объясним новое ключевое слово, связанное с исключениями.

* **try**-функция, использующая исключение, должна быть в блоке «try». Если исключение не запускается, код будет продолжен как обычно. Однако, если исключение инициируется, исключение «бросается».

* **Throw** - это то, как вы вызываете исключение. Каждый «бросок» должен иметь хотя бы один «улов».

* **Catch** - блок «catch» извлекает исключение и создает объект, содержащий информацию об исключении

Когда генерируется исключение, код, следующий за оператором, не будет выполнен, а PHP попытается найти первый соответствующий блок catch. Если исключение не поймано, PHP Fatal Error будет выпущена с помощью «Uncaught Exception ...

* Исключение можно выбросить и поймать («поймать») в PHP. Код может быть окружен в блоке try.

* Каждая попытка должна иметь по крайней мере один соответствующий блок catch. Для блокировки различных классов исключений можно использовать несколько блоков catch.

* Исключения могут быть сброшены (или повторно выбраны) в блоке catch.

### Пример

```
<?php
   try {
      $error = 'Always throw this error';
      throw new Exception($error);
      
      // Code following an exception is not executed.
      echo 'Never executed';
   }catch (Exception $e) {
      echo 'Caught exception: ',  $e->getMessage(), "\n";
   }
   
   // Continue execution
   echo 'Hello World';
?>
```
В приведенном выше примере функция $ e-> getMessage используется для получения сообщения об ошибке. 
Существуют следующие функции, которые могут использоваться из класса Exception.

* **getMessage ()**- сообщение об исключении

* **getCode ()** - код исключения

* **getFile ()** - исходное имя файла

* **getLine ()** - исходная строка

* **getTrace ()** - n массив backtrace ()

* **getTraceAsString ()** - сформированная строка трассировки

### Создание настраиваемого обработчика исключений

Вы можете определить собственный собственный обработчик исключений. 
Используйте следующую функцию для установки пользовательской функции обработчика исключений.

```string set_exception_handler ( callback $exception_handler )```

Здесь exception_handler - это имя вызываемой функции, когда происходит неперехваченное исключение.
Эта функция должна быть определена перед вызовом set_exception_handler ().

### Пример

```
<?php
   function exception_handler($exception) {
      echo "Uncaught exception: " , $exception->getMessage(), "\n";
   }
	
   set_exception_handler('exception_handler');
   throw new Exception('Uncaught Exception');
   
   echo "Not Executed\n";
?>
```
